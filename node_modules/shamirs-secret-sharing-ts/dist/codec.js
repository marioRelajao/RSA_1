"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const table_1 = require("./table");
const constants_1 = require("./constants");
function pad(text, multiple) {
    let missing = 0;
    let result = text;
    if (!multiple) {
        multiple = constants_1.BIT_COUNT;
    }
    if (text) {
        missing = text.length % multiple;
    }
    if (missing) {
        const offset = -((multiple - missing) + text.length);
        result = (table_1.zeroes + text).slice(offset);
    }
    return result;
}
exports.pad = pad;
function hex(buffer, encoding) {
    const padding = 2 * constants_1.BYTES_PER_CHARACTER;
    if (!encoding) {
        encoding = constants_1.UTF8_ENCODING;
    }
    if ('string' === typeof buffer) {
        return fromString();
    }
    if (Buffer.isBuffer(buffer)) {
        return fromBuffer();
    }
    throw new TypeError('Expecting a string or buffer as input.');
    function fromString() {
        const chunks = [];
        if (constants_1.UTF8_ENCODING === encoding) {
            for (let i = 0; i < buffer.length; ++i) {
                const chunk = Number(String.fromCharCode(buffer[i])).toString(16);
                chunks.unshift(pad(chunk, padding));
            }
        }
        if (constants_1.BIN_ENCODING === encoding) {
            buffer = pad(buffer, 4);
            for (let i = buffer.length; i >= 4; i -= 4) {
                const bits = buffer.slice(i - 4, i);
                const chunk = parseInt(bits, 2).toString(16);
                chunks.unshift(chunk);
            }
        }
        return chunks.join('');
    }
    function fromBuffer() {
        const chunks = [];
        for (let i = 0; i < buffer.length; ++i) {
            const chunk = buffer[i].toString(16);
            chunks.unshift(pad(chunk, padding));
        }
        return chunks.join('');
    }
}
exports.hex = hex;
function bin(buffer, radix) {
    const chunks = [];
    if (!radix) {
        radix = 16;
    }
    for (let i = buffer.length - 1; i >= 0; --i) {
        let chunk = null;
        if (Buffer.isBuffer(buffer)) {
            chunk = buffer[i];
        }
        if ('string' === typeof buffer) {
            chunk = parseInt(buffer[i], radix);
        }
        if (Array.isArray(buffer)) {
            chunk = buffer[i];
            if ('string' === typeof chunk) {
                chunk = parseInt(chunk, radix);
            }
        }
        if (null === chunk) {
            throw new TypeError('Unsupported type for chunk in buffer array.');
        }
        chunks.unshift(pad(chunk.toString(2), 4));
    }
    return chunks.join('');
}
exports.bin = bin;
function encode(id, data) {
    id = parseInt(id, 16);
    const padding = (constants_1.BIT_SIZE - 1).toString(16).length;
    const header = Buffer.concat([
        Buffer.from(constants_1.BIT_COUNT.toString(36).toUpperCase()),
        Buffer.from(pad(id.toString(16), padding))
    ]);
    if (false === Buffer.isBuffer(data)) {
        data = Buffer.from(data);
    }
    return Buffer.concat([header, data]);
}
exports.encode = encode;
function decode(buffer, encoding) {
    const padding = 2 * constants_1.BYTES_PER_CHARACTER;
    const offset = padding;
    const chunks = [];
    if (Buffer.isBuffer(buffer)) {
        buffer = buffer.toString(encoding);
    }
    buffer = pad(buffer, padding);
    for (let i = 0; i < buffer.length; i += offset) {
        const bits = buffer.slice(i, i + offset);
        const chunk = parseInt(bits, 16);
        chunks.unshift(chunk);
    }
    return Buffer.from(chunks);
}
exports.decode = decode;
function split(string, padding, radix) {
    const chunks = [];
    let i = 0;
    if (Buffer.isBuffer(string)) {
        string = string.toString();
    }
    if (padding) {
        string = pad(string, padding);
    }
    for (i = string.length; i > constants_1.BIT_COUNT; i -= constants_1.BIT_COUNT) {
        const bits = string.slice(i - constants_1.BIT_COUNT, i);
        const chunk = parseInt(bits, radix);
        chunks.push(chunk);
    }
    chunks.push(parseInt(string.slice(0, i), radix));
    return chunks;
}
exports.split = split;
